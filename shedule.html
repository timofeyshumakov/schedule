<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Планирование заказов</title>
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@6.x/css/materialdesignicons.min.css" rel="stylesheet">
    <style>
        /* Стили остаются без изменений */
        .wrapper {
            margin: 0.5rem 0;
        }
        @media (max-width: 900px) {
            .wrapper  {
                margin: 0;
            }
        }
        .buttons{
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
        }
        .load-cell {
            min-width: 80px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        .load-cell.weekend {
            background-color: #f5f5f5;
        }
        .load-cell.vacation {
            background-color: #fff8e1;
        }
        .load-cell.sick {
            background-color: #ffebee;
        }
        .load-cell.working {
            background-color: #e8f5e9;
        }
        .load-cell.terminated {
        background-color: #f5f5f5;
        opacity: 0.7;
        }
        .load-cell.not-hired {
            background-color: #f5f5f5;
            opacity: 0.7;
        }
        .main-table table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Roboto', sans-serif;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        #loadChart{
            overflow-x: scroll !important;
            overflow-y: hidden !important;
        }
        .main-table thead {
            background-color: #1976D2;
            color: white;
        }

        .main-table thead th {
            padding: 12px 16px;
            text-align: left;
            font-weight: 500;
            font-size: 0.875rem;
            letter-spacing: 0.01071em;
            border-bottom: 1px solid rgba(224, 224, 224, 0.5);
        }

        .main-table tbody tr {
            border-bottom: 1px solid #e0e0e0;
            transition: background-color 0.2s ease;
        }

        .main-table tbody tr:hover {
            background-color: rgba(25, 118, 210, 0.04);
        }

        .main-table tbody td {
            padding: 12px 16px;
            font-size: 0.875rem;
            color: rgba(0, 0, 0, 0.87);
        }

        .main-table .load-cell {
            text-align: center;
            padding: 8px 12px;
            min-width: 5.5rem;
        }

        .main-table .weekend {
            background-color: #f5f5f5;
            color: #757575;
        }

        .main-table tbody td:first-child {
            font-weight: 500;
            color: rgba(0, 0, 0, 0.87);
        }

        .main-table .v-icon {
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .main-table.v-icon:hover {
            transform: scale(1.2);
        }

        .main-table tbody tr:nth-child(even) {
            background-color: #fafafa;
        }

        .main-table tbody tr:nth-child(even):hover {
            background-color: rgba(25, 118, 210, 0.04);
        }

        @media (max-width: 600px) {
            .main-table thead th, .main-table tbody td {
                padding: 8px 12px;
                font-size: 0.75rem;
            }
            
            .load-cell {
                min-width: 32px;
                padding: 4px 2px;
            }
        }
        #loadChart {
            width: 100%;
            height: 400px;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="app">
        <v-app>
            <!-- Loading Overlay -->
            <div v-if="loading" class="loading-overlay">
                <v-progress-circular indeterminate size="64" color="primary"></v-progress-circular>
            </div>

            <v-app-bar app color="primary" dark>
                <v-toolbar-title>Планирование заказов</v-toolbar-title>
                <v-spacer></v-spacer>
                <v-btn text @click="planning">Планирование</v-btn>
                <v-btn v-if="isAdmin" text @click="loadTable">Рабочие графики</v-btn>
            </v-app-bar>

            <v-main>
                <v-container fluid>
                    <v-alert v-if="errorMessage" type="error" dismissible @input="errorMessage = ''">
                        {{ errorMessage }}
                    </v-alert>

                    <v-alert v-if="successMessage" type="success" dismissible @input="successMessage = ''">
                        {{ successMessage }}
                    </v-alert>

                    <div v-if="currentView === 'planning'">
                        <v-row>
                            <v-col cols="12" md="6">
                                <v-card>
                                    <v-card-title>Новая сделка</v-card-title>
                                    <v-card-text>
                                        <v-text-field 
                                            v-model.number="newDeal.manDays" 
                                            type="number" 
                                            label="Человеко-дни"
                                            min="1"
                                            :disabled="loading"
                                        ></v-text-field>
                                        <v-menu 
                                            v-model="dealDateMenu1" 
                                            :close-on-content-click="false" 
                                            max-width="290"
                                            :locale="ruLocale"
                                        >
                                            <template v-slot:activator="{ on }">
                                                <v-text-field 
                                                    v-model="newDeal.startDate" 
                                                    label="Дата с" 
                                                    readonly 
                                                    v-on="on"
                                                    prepend-icon="mdi-calendar"
                                                    :disabled="loading"
                                                ></v-text-field>
                                            </template>
                                            <v-date-picker 
                                                v-model="newDeal.startDate" 
                                                @input="dealDateMenu1 = false"
                                                :locale="ruLocale"
                                                :first-day-of-week="1"
                                                :max="newDeal.endDate"
                                            ></v-date-picker>
                                        </v-menu>
                                        <v-menu 
                                            v-model="dealDateMenu2" 
                                            :close-on-content-click="false" 
                                            max-width="290"
                                            :locale="ruLocale"
                                        >
                                            <template v-slot:activator="{ on }">
                                                <v-text-field 
                                                    v-model="newDeal.endDate" 
                                                    label="Дата по" 
                                                    readonly 
                                                    v-on="on"
                                                    prepend-icon="mdi-calendar"
                                                    :disabled="loading"
                                                ></v-text-field>
                                            </template>
                                            <v-date-picker 
                                                v-model="newDeal.endDate" 
                                                @input="dealDateMenu2 = false"
                                                :locale="ruLocale"
                                                :first-day-of-week="1"
                                                :min="newDeal.startDate"
                                            ></v-date-picker>
                                        </v-menu>
                                        <v-btn color="primary" @click="checkDeal" :loading="checkingDeal" :disabled="loading">
                                            Проверить возможность
                                        </v-btn>
                                        <v-alert v-if="dealCheckResult" :type="canAddDeal ? 'success' : 'error'" class="mt-4">
                                            {{ dealCheckResult }}
                                        </v-alert>
                                        <v-btn v-if="canAddDeal" color="success" @click="addDeal" class="mt-2" :disabled="loading">
                                            Добавить даты в сделку
                                        </v-btn>
                                    </v-card-text>
                                </v-card>
                            </v-col>
                        </v-row>

                        <v-row>
                            <v-col cols="12">
                                <v-card>
                                    <v-card-title>График загрузки</v-card-title>
                                    <v-card-text>
                                        <div class="chart-container" id="chartContainer" @wheel="handleChartWheel">
                                                <div id="loadChart"></div>
                                        </div>
                                    </v-card-text>
                                </v-card>
                            </v-col>
                        </v-row>
                    </div>

                    <div v-if="currentView === 'loadTable'">
                        <v-row>
                            <v-col cols="12">
                                <v-card>
                                    <v-card-title>Рабочие графики сотрудников</v-card-title>
                                    <v-card-text>
                                        <v-row>
                                            <v-col cols="12" md="4">
                                                <v-menu 
                                                    v-model="tableDateMenu1" 
                                                    :close-on-content-click="false" 
                                                    max-width="290"
                                                    :locale="ruLocale"
                                                >
                                                    <template v-slot:activator="{ on }">
                                                        <v-text-field 
                                                            v-model="tableDateStart" 
                                                            label="Дата с" 
                                                            readonly 
                                                            v-on="on"
                                                            prepend-icon="mdi-calendar"
                                                            :disabled="loading"
                                                        ></v-text-field>
                                                    </template>
                                                    <v-date-picker 
                                                        v-model="tableDateStart" 
                                                        @input="updateTableDates"
                                                        :locale="ruLocale"
                                                        :first-day-of-week="1"
                                                        :max="tableDateEnd"
                                                    ></v-date-picker>
                                                </v-menu>
                                            </v-col>
                                            <v-col cols="12" md="4">
                                                <v-menu 
                                                    v-model="tableDateMenu2" 
                                                    :close-on-content-click="false" 
                                                    max-width="290"
                                                    :locale="ruLocale"
                                                >
                                                    <template v-slot:activator="{ on }">
                                                        <v-text-field 
                                                            v-model="tableDateEnd" 
                                                            label="Дата по" 
                                                            readonly 
                                                            v-on="on"
                                                            prepend-icon="mdi-calendar"
                                                            :disabled="loading"
                                                        ></v-text-field>
                                                    </template>
                                                    <v-date-picker 
                                                        v-model="tableDateEnd" 
                                                        @input="updateTableDates"
                                                        :locale="ruLocale"
                                                        :first-day-of-week="1"
                                                        :min="tableDateStart"
                                                    ></v-date-picker>
                                                </v-menu>
                                            </v-col>
                                        </v-row>
                                        
                                        <div style="overflow-x: auto;" class="table-wrapper" ref="tableWrapper" @wheel="handleWheelScroll">
                                            <table class="main-table">
                                                <thead>
                                                    <tr>
                                                        <th style="min-width: 150px;">Сотрудник</th>
                                                        <th v-for="date in tableDates" :key="date" class="load-cell" 
                                                            :class="{ 'weekend': isWeekend(date) }">
                                                            {{ formatTableDate(date) }}
                                                        </th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr v-for="employee in employees" :key="employee.id">
                                                        <template>
                                                            <td>{{ employee.name }}</td>
                                                            <td v-for="date in tableDates" 
                                                                :key="date" 
                                                                class="load-cell"
                                                                :class="getCellClass(employee, date)"
                                                                @click="changeIcon(employee, date)"
                                                            >
                                                                <v-icon 
                                                                    :color="getCellContent(employee, date).color"
                                                                    :title="getCellContent(employee, date).tooltip"
                                                                >
                                                                    {{ getCellContent(employee, date).icon }}
                                                                </v-icon>
                                                            </td>
                                                        </template>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                    </v-card-text>
                                </v-card>
                            </v-col>
                        </v-row>

                        <v-row>
                            <v-col cols="12" md="6">
                                <v-card>
                                    <v-card-title>Управление графиком</v-card-title>
                                    <v-card-text>
                                        <v-autocomplete 
                                            v-model="selectedEmployee" 
                                            :items="employees" 
                                            label="Сотрудник" 
                                            item-text="name" 
                                            return-object
                                            :menu-props="{ closeOnContentClick: true }"
                                            :disabled="loading"
                                        ></v-autocomplete>
                                        <v-autocomplete
                                            v-model="scheduleAction" 
                                            :items="scheduleActions"
                                            item-title="text"
                                            item-value="value"
                                            label="Действие"
                                            :menu-props="{ closeOnContentClick: true }"
                                            :disabled="loading"
                                        ></v-autocomplete>
                                        <v-menu 
                                            v-if="showDatePickers"
                                            v-model="dateMenu1" 
                                            :close-on-content-click="false" 
                                            max-width="290"
                                            :locale="ruLocale"
                                        >
                                            <template v-slot:activator="{ on }">
                                                <v-text-field 
                                                    v-model="scheduleDateStart" 
                                                    label="Дата с" 
                                                    readonly 
                                                    v-on="on"
                                                    prepend-icon="mdi-calendar"
                                                    :disabled="loading"
                                                ></v-text-field>
                                            </template>
                                            <v-date-picker 
                                                v-model="scheduleDateStart" 
                                                @input="dateMenu1 = false"
                                                :locale="ruLocale"
                                                :first-day-of-week="1"
                                            ></v-date-picker>
                                        </v-menu>
                                        <v-menu 
                                            v-if="showDatePickers"
                                            v-model="dateMenu2" 
                                            :close-on-content-click="false" 
                                            max-width="290"
                                            :locale="ruLocale"
                                        >
                                            <template v-slot:activator="{ on }">
                                                <v-text-field 
                                                    v-model="scheduleDateEnd" 
                                                    label="Дата по" 
                                                    readonly 
                                                    v-on="on"
                                                    prepend-icon="mdi-calendar"
                                                    :disabled="loading"
                                                ></v-text-field>
                                            </template>
                                            <v-date-picker 
                                                v-model="scheduleDateEnd" 
                                                @input="dateMenu2 = false"
                                                :locale="ruLocale"
                                                :first-day-of-week="1"
                                            ></v-date-picker>
                                        </v-menu>
                                        <v-btn color="primary" @click="applySchedule" :loading="loading" :disabled="!selectedEmployee">
                                            Применить
                                        </v-btn>
                                    </v-card-text>
                                </v-card>
                            </v-col>

                            <v-col cols="12" md="6">
                                <v-card>
                                    <v-card-title>Управление сотрудниками</v-card-title>
                                    <v-card-text>
                                        <v-text-field 
                                            v-model="newEmployee.name" 
                                            label="Имя сотрудника"
                                            :disabled="loading"
                                        ></v-text-field>
                                        <v-btn color="primary" @click="addEmployee" :loading="addingEmployee" :disabled="loading">
                                            Добавить
                                        </v-btn>
                                        <v-autocomplete
                                            v-model="selectedEmployeeForDelete" 
                                            :items="employees" 
                                            label="Сотрудник" 
                                            item-text="name" 
                                            return-object
                                            :menu-props="{ closeOnContentClick: true }"
                                            class="mt-4"
                                            :disabled="loading"
                                        ></v-autocomplete>
                                        <div class="buttons">
                                            <v-btn color="error" @click="confirmRemoveEmployee" :loading="deletingEmployee" 
                                                :disabled="!selectedEmployeeForDelete || loading">
                                                Уволить
                                            </v-btn>
                                            <v-btn color="warning" @click="openEditEmployeeDialog" :loading="loading" 
                                                :disabled="!selectedEmployeeForDelete" class="mt-2">
                                                Редактировать
                                            </v-btn>
                                        </div>
                                    </v-card-text>
                                </v-card>
                            </v-col>
                        </v-row>
                    </div>

                    <!-- Диалог изменения статуса -->
                    <v-dialog v-model="iconDialog" max-width="500">
                        <v-card>
                            <v-card-title>Выберите статус для {{ currentEmployee ? currentEmployee.name : '' }}</v-card-title>
                            <v-card-text>
                                <v-radio-group v-model="selectedStatus">
                                    <v-radio value="working" color="green">
                                        <template v-slot:label>
                                            <v-icon color="green">mdi-briefcase</v-icon>
                                            <span class="ml-2">Рабочий день</span>
                                        </template>
                                    </v-radio>
                                    <v-radio value="vacation" color="orange">
                                        <template v-slot:label>
                                            <v-icon color="orange">mdi-palm-tree</v-icon>
                                            <span class="ml-2">Отпуск</span>
                                        </template>
                                    </v-radio>
                                    <v-radio value="sick" color="red">
                                        <template v-slot:label>
                                            <v-icon color="red">mdi-hospital-box</v-icon>
                                            <span class="ml-2">Больничный</span>
                                        </template>
                                    </v-radio>
                                    <v-radio value="weekend" color="grey">
                                        <template v-slot:label>
                                            <v-icon color="grey">mdi-sofa</v-icon>
                                            <span class="ml-2">Выходной</span>
                                        </template>
                                    </v-radio>
                                    <v-radio value="terminated" color="grey darken-2">
                                        <template v-slot:label>
                                            <v-icon color="grey darken-2">mdi-account-off</v-icon>
                                            <span class="ml-2">Уволен</span>
                                        </template>
                                    </v-radio>
                                    <v-radio value="not_hired" color="blue-grey lighten-2">
                                        <template v-slot:label>
                                            <v-icon color="blue-grey lighten-2">mdi-account-clock</v-icon>
                                            <span class="ml-2">Еще не принят</span>
                                        </template>
                                    </v-radio>
                                </v-radio-group>
                            </v-card-text>
                            <v-card-actions>
                                <v-spacer></v-spacer>
                                <v-btn color="primary" @click="saveIconChange" :loading="savingStatus">Сохранить</v-btn>
                                <v-btn color="secondary" @click="iconDialog = false">Отмена</v-btn>
                            </v-card-actions>
                        </v-card>
                    </v-dialog>
                    <v-dialog v-model="editEmployeeDialog" max-width="500">
                        <v-card>
                            <v-card-title>Редактирование сотрудника</v-card-title>
                            <v-card-text>
                                <v-text-field 
                                    v-model="editEmployeeData.name" 
                                    label="Имя сотрудника"
                                    :disabled="loading"
                                ></v-text-field>
                                
                                <v-menu 
                                    v-model="editHireDateMenu" 
                                    :close-on-content-click="false" 
                                    max-width="290"
                                    :locale="ruLocale"
                                >
                                    <template v-slot:activator="{ on }">
                                        <v-text-field 
                                            v-model="editEmployeeData.created_at" 
                                            label="Дата приема на работу" 
                                            readonly 
                                            v-on="on"
                                            prepend-icon="mdi-calendar"
                                            :disabled="loading"
                                        ></v-text-field>
                                    </template>
                                    <v-date-picker 
                                        v-model="editEmployeeData.created_at" 
                                        @input="editHireDateMenu = false"
                                        :locale="ruLocale"
                                        :first-day-of-week="1"
                                    ></v-date-picker>
                                </v-menu>

                                <v-menu 
                                    v-model="editTerminationDateMenu" 
                                    :close-on-content-click="false" 
                                    max-width="290"
                                    :locale="ruLocale"
                                >
                                    <template v-slot:activator="{ on }">
                                        <v-text-field 
                                            v-model="editEmployeeData.termination_date" 
                                            label="Дата увольнения" 
                                            readonly 
                                            v-on="on"
                                            prepend-icon="mdi-calendar"
                                            :disabled="loading"
                                            clearable
                                        ></v-text-field>
                                    </template>
                                    <v-date-picker 
                                        v-model="editEmployeeData.termination_date" 
                                        @input="editTerminationDateMenu = false"
                                        :locale="ruLocale"
                                        :first-day-of-week="1"
                                        :min="editEmployeeData.created_at"
                                    ></v-date-picker>
                                </v-menu>

                                <v-checkbox
                                    v-model="editEmployeeData.clearTerminationDate"
                                    label="Снять дату увольнения"
                                    @change="clearTerminationDate"
                                ></v-checkbox>
                            </v-card-text>
                            <v-card-actions>
                                <v-spacer></v-spacer>
                                <v-btn color="error" @click="deleteEmployeePermanently" :loading="deletingEmployee">
                                    Удалить
                                </v-btn>
                                <v-btn color="primary" @click="saveEmployeeEdit" :loading="savingEmployee">Сохранить</v-btn>
                                <v-btn color="secondary" @click="editEmployeeDialog = false">Отмена</v-btn>
                            </v-card-actions>
                        </v-card>
                    </v-dialog>
                </v-container>
            </v-main>
        </v-app>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.x"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
    <script src="highcharts.js"></script>
    <script src="https://code.highcharts.com/lang/ru.js"></script>
    <script src="https://code.highcharts.com/modules/exporting.js"></script>
    <script src="https://code.highcharts.com/modules/export-data.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/locale/ru.js"></script>
    <script src="//api.bitrix24.com/api/v1/"></script>
    <script type="module">
        moment.locale('ru');
        //import { callApi } from "./src/functions/callApi";
        const API_BASE =  'http://localhost/shedule/api';
        new Vue({
            el: '#app',
            vuetify: new Vuetify({
                lang: {
                    locales: [ 'ru' ],
                    current: 'ru'
                },
                date: {
                    locale: 'ru',
                    firstDayOfWeek: 1
                }
            }),
            data() {
                return {
                    editEmployeeDialog: false,
                    editEmployeeData: {
                        id: null,
                        name: '',
                        created_at: '',
                        termination_date: null,
                        clearTerminationDate: false
                    },
                    editHireDateMenu: false,
                    editTerminationDateMenu: false,
                    savingEmployee: false,
                    isAdmin: false,
                    applyProductionCalendar: false,
                    loading: false,
                    loadingCalendar: false,
                    applyingCalendar: false,
                    checkingDeal: false,
                    addingEmployee: false,
                    deletingEmployee: false,
                    savingStatus: false,
                    errorMessage: '',
                    successMessage: '',
                    productionCalendar: [],
                    currentYear: new Date().getFullYear(),
                    currentView: 'planning',
                    ruLocale: {
                        firstDayOfWeek: 1,
                        masks: {
                            weekdays: ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'],
                            months: [
                                'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
                                'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
                            ]
                        }
                    },
                    employees: [],
                    deals: [],

                    // Для диалога статуса
                    iconDialog: false,
                    currentEmployee: null,
                    currentDate: null,
                    selectedStatus: null,

                    // Управление сотрудниками
                    newEmployee: { name: '' },
                    selectedEmployeeForDelete: null,

                    // Управление графиком
                    selectedEmployee: null,
                    scheduleAction: 'weekend',
                    scheduleActions: [
                        { text: 'Рабочий день', value: 'working' },
                        { text: 'Отпуск', value: 'vacation' },
                        { text: 'Больничный', value: 'sick' },
                        { text: 'Выходной', value: 'weekend' },
                        { text: 'Уволен', value: 'terminated' },
                        { text: 'Еще не принят', value: 'not_hired' },
                        { text: 'По производственному календарю', value: 'production_calendar' }
                    ],
                    scheduleDateStart: moment().format('YYYY-MM-DD'), 
                    scheduleDateEnd: moment().add(1, 'week').format('YYYY-MM-DD'),
                    dateMenu1: false,
                    dateMenu2: false,

                    // Для сделок
                    newDeal: { 
                        manDays: 5, 
                        startDate: '', 
                        endDate: '', 
                    },
                    dealDateMenu1: false,
                    dealDateMenu2: false,
                    dealCheckResult: null,
                    canAddDeal: false,

                    // Для таблицы загрузки
                    tableDateStart: moment().format('YYYY-MM-DD'),
                    tableDateEnd: moment().add(4, 'week').format('YYYY-MM-DD'),
                    tableDates: [],
                    tableDateMenu1: false,
                    tableDateMenu2: false,
                    productionCalendars: {}, // Хранит календари по годам: {2024: [...], 2025: [...]}
                    currentYear: new Date().getFullYear(),
                    occupancyCache: {}, // Кэш для рассчитанной занятости
                    availableManDaysCache: {}, // Кэш для доступных человеко-дней
                    lastDealsUpdate: null, // Время последнего обновления сделок
                    cacheValid: false, // Флаг валидности кэша
                };
            },
            computed: {
                tableDaysCount() {
                    if (!this.tableDateStart || !this.tableDateEnd) return 0;
                    const start = moment(this.tableDateStart);
                    const end = moment(this.tableDateEnd);
                    this.loadScheduleData();
                    return end.diff(start, 'days') + 1;
                },
                // Добавьте это вычисляемое свойство
                showDatePickers() {
                    return this.scheduleAction !== 'production_calendar';
                },
            },
            methods: {
                initCache() {
        this.occupancyCache = {};
        this.availableManDaysCache = {};
        this.cacheValid = false;
    },

    // Инвалидация кэша при изменении данных
    invalidateCache() {
        this.cacheValid = false;
        this.occupancyCache = {};
        this.availableManDaysCache = {};
    },

    // Оптимизированный метод получения занятых человеко-дней с кэшированием
    async getOccupiedManDays(date) {
        // Проверяем кэш и валидность данных
        if (this.occupancyCache[date] !== undefined && this.cacheValid) {
            const available = this.getAvailableManDays(date);
            return Math.min(this.occupancyCache[date], available);
        }

        let totalLoad = 0;
        const currentMoment = moment(date);
        const availableManDays = this.getAvailableManDays(date);
        
        // Используем более эффективный алгоритм фильтрации сделок
        const relevantDeals = this.deals.filter(deal => {
            const dealStart = moment(deal.UF_CRM_1755511210978).subtract(1, 'day');
            const dealEnd = moment(deal.UF_CRM_1755511228885);
            return currentMoment.isBetween(dealStart, dealEnd, null, '[]');
        });

        // Предварительно вычисляем рабочие дни для каждой сделки
        const dealWorkDays = new Map();
        
        for (const deal of relevantDeals) {
            const dealId = deal.ID || deal.id;
            if (!dealWorkDays.has(dealId)) {
                const dealStart = moment(deal.UF_CRM_1755511210978).subtract(1, 'day');
                const dealEnd = moment(deal.UF_CRM_1755511228885);
                const workDays = this.countWorkDaysInPeriod(dealStart, dealEnd) - 1;
                dealWorkDays.set(dealId, workDays);
            }
        }

        // Рассчитываем нагрузку
        for (const deal of relevantDeals) {
            const dealId = deal.ID || deal.id;
            const workDaysInDeal = dealWorkDays.get(dealId);
            
            if (workDaysInDeal > 0) {
                const dailyLoad = deal.UF_CRM_1755511268203 / workDaysInDeal;
                
                if (totalLoad + dailyLoad > availableManDays) {
                    totalLoad = availableManDays;
                    break;
                } else {
                    totalLoad += dailyLoad;
                }
            }
        }
        
        // Сохраняем в кэш
        this.occupancyCache[date] = totalLoad;
        
        return Math.min(totalLoad, availableManDays);
    },

    // Оптимизированный метод получения доступных человеко-дней с кэшированием
    getAvailableManDays(date) {
        if (this.availableManDaysCache[date] !== undefined && this.cacheValid) {
            return this.availableManDaysCache[date];
        }

        const dateMoment = moment(date);
        // Используем более эффективный подход с предварительной фильтрацией
        const availableCount = this.employees.reduce((count, emp) => {
            // Быстрая проверка дат приема/увольнения
            if (emp.created_at && moment(emp.created_at).isAfter(dateMoment, 'day')) {
                return count;
            }
            if (emp.termination_date && moment(emp.termination_date).isBefore(dateMoment, 'day')) {
                return count;
            }

            const status = emp.schedule[date];
            
            if (status === 'working') return count + 1;
            if (status === 'vacation' || status === 'sick' || status === 'weekend' || 
                status === 'terminated' || status === 'not_hired') return count;
            
            return this.isWeekend(date) ? count : count + 1;
        }, 0);

        const result = Math.max(0, availableCount);
        this.availableManDaysCache[date] = result;
        return result;
    },

    // Пакетный расчет для диапазона дат
    async preCalculateOccupancyForRange(startDate, endDate) {
        const dates = [];
        const current = moment(startDate);
        const end = moment(endDate);
        
        while (current.isSameOrBefore(end)) {
            const dateStr = current.format('YYYY-MM-DD');
            if (!this.isWeekend(dateStr)) {
                dates.push(dateStr);
            }
            current.add(1, 'day');
        }

        // Параллельный расчет для всех дат
        const calculationPromises = dates.map(date => 
            this.getOccupiedManDays(date).then(occupied => ({
                date,
                occupied,
                available: this.getAvailableManDays(date)
            }))
        );

        const results = await Promise.all(calculationPromises);
        
        // Сохраняем результаты в кэш
        results.forEach(result => {
            this.occupancyCache[result.date] = result.occupied;
            this.availableManDaysCache[result.date] = result.available;
        });

        this.cacheValid = true;
        return results;
    },

                isEmployeeTerminated(employee, date) {
        if (!employee.termination_date) return false;
        return moment(date).isAfter(moment(employee.termination_date), 'day');
    },

    // Метод для проверки, является ли сотрудник принятым на определенную дату
    isEmployeeHired(employee, date) {
        if (!employee.created_at) return true; // Если дата приема не указана, считаем принятым
        return moment(date).isSameOrAfter(moment(employee.created_at), 'day');
    },
updateTableDates() {
    this.tableDates = [];
    const start = moment(this.tableDateStart);
    const end = moment(this.tableDateEnd);
    
    // Определяем, какие годы охватывает период
    const yearsInPeriod = new Set();
    let current = start.clone();
    
    while (current.isSameOrBefore(end)) {
        yearsInPeriod.add(current.year());
        current.add(1, 'day');
    }
    
    // Загружаем календари для всех лет в периоде
    yearsInPeriod.forEach(year => {
        if (year !== this.currentYear) { // Не загружаем текущий год повторно
            this.loadProductionCalendarForYear(year);
        }
    });
    
    // Генерируем даты для таблицы
    current = start.clone();
    for (let i = 0; i < this.tableDaysCount; i++) {
        this.tableDates.push(current.clone().add(i, 'days').format('YYYY-MM-DD'));
    }
},
async loadProductionCalendarForYear(year) {
    this.loadingCalendar = true;
    try {
        // Проверяем, есть ли уже загруженный календарь для этого года
        if (this.productionCalendars && this.productionCalendars[year]) {
            this.productionCalendar = this.productionCalendars[year];
            return;
        }

        const response = await fetch(`https://isdayoff.ru/api/getdata?year=${year}&delimeter=,`);
        const csvData = await response.text();
        
        const calendar = [];
        const lines = csvData.split(',');
        
        // Проверяем, если пришли все нули (календаря на следующий год еще нет)
        const allZeros = lines.every(line => line.trim() === '0');
        
        if (allZeros) {
            // Если календаря нет, создаем стандартный (пн-пт рабочие, сб-вс выходные)
            for (let month = 1; month <= 12; month++) {
                for (let day = 1; day <= 31; day++) {
                    const dateStr = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                    const date = moment(dateStr);
                    if (date.isValid() && date.year() === year) {
                        const dayOfWeek = date.day();
                        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6; // вс=0, сб=6
                        calendar.push({
                            date: dateStr,
                            type: isWeekend ? 'weekend' : 'working',
                            description: isWeekend ? 'Выходной' : 'Рабочий день'
                        });
                    }
                }
            }
        } else {
            // Если календарь есть, парсим его
            for (let month = 1; month <= 12; month++) {
                for (let day = 1; day <= 31; day++) {
                    const dateStr = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                    const date = moment(dateStr);
                    if (date.isValid() && date.year() === year) {
                        const dayIndex = date.dayOfYear() - 1;
                        if (dayIndex < lines.length) {
                            const dayType = lines[dayIndex].trim();
                            calendar.push({
                                date: dateStr,
                                type: dayType === '1' ? 'weekend' : 'working',
                                description: dayType === '1' ? 'Выходной/праздничный' : 'Рабочий день'
                            });
                        }
                    }
                }
            }
        }
        
        // Сохраняем календарь для этого года
        if (!this.productionCalendars) {
            this.productionCalendars = {};
        }
        this.productionCalendars[year] = calendar;
        this.productionCalendar = calendar;
        
    } catch (error) {
        console.error('Ошибка загрузки производственного календаря:', error);
        // В случае ошибки создаем стандартный календарь
        this.createDefaultCalendar(year);
    } finally {
        this.loadingCalendar = false;
    }
},
clearTerminationDate() {
    if (this.editEmployeeData.clearTerminationDate) {
        this.editEmployeeData.termination_date = '';
    }
},
async deleteEmployeePermanently() {
    if (!this.editEmployeeData.id) return;

    if (!confirm('Вы уверены, что хотите полностью удалить сотрудника? Это действие нельзя отменить.')) {
        return;
    }

    this.deletingEmployee = true;
    try {
        // Сначала удаляем все записи расписания сотрудника
        await this.apiCall(`${API_BASE}/schedule.php`, {
            method: 'DELETE',
            body: JSON.stringify({
                employee_id: this.editEmployeeData.id,
                delete_all: true
            })
        });

        // Затем удаляем самого сотрудника
        await this.apiCall(`${API_BASE}/employees.php`, {
            method: 'DELETE',
            body: JSON.stringify({
                id: this.editEmployeeData.id,
                permanent: true
            })
        });
        
        this.editEmployeeDialog = false;
        this.selectedEmployeeForDelete = null;
        await this.loadEmployees();
        this.showSuccess('Сотрудник полностью удален');
    } catch (error) {
        this.showError('Ошибка удаления сотрудника: ' + error.message);
    } finally {
        this.deletingEmployee = false;
    }
},
// Метод для сохранения изменений сотрудника
async saveEmployeeEdit() {
    if (!this.editEmployeeData.name) {
        this.showError('Введите имя сотрудника');
        return;
    }

    this.savingEmployee = true;
    try {
        const updateData = {
            id: this.editEmployeeData.id,
            name: this.editEmployeeData.name,
            created_at: this.editEmployeeData.created_at
        };

        // Если установлен флаг снятия даты увольнения или явно указана пустая строка
        if (this.editEmployeeData.clearTerminationDate || this.editEmployeeData.termination_date === '') {
            updateData.termination_date = null;
        } else if (this.editEmployeeData.termination_date) {
            updateData.termination_date = this.editEmployeeData.termination_date;
        }

        await this.apiCall(`${API_BASE}/employees.php`, {
            method: 'PUT',
            body: JSON.stringify(updateData)
        });
        
        this.editEmployeeDialog = false;
        await this.loadEmployees();
        await this.loadScheduleData();
        this.showSuccess('Данные сотрудника обновлены');
    } catch (error) {
        this.showError('Ошибка обновления сотрудника: ' + error.message);
    } finally {
        this.savingEmployee = false;
    }
},
formatDateForDisplay(dateStr) {
    if (!dateStr) return '';
    // Если дата содержит время, обрезаем до даты
    if (dateStr.includes(' ')) {
        return dateStr.split(' ')[0];
    }
    if (dateStr.includes('T')) {
        return dateStr.split('T')[0];
    }
    return dateStr;
},
// Метод для открытия диалога редактирования
openEditEmployeeDialog() {
    if (!this.selectedEmployeeForDelete) {
        this.showError('Выберите сотрудника для редактирования');
        return;
    }

    this.editEmployeeData = {
        id: this.selectedEmployeeForDelete.id,
        name: this.selectedEmployeeForDelete.name,
        created_at: this.editEmployeeData.created_at || moment().format('YYYY-MM-DD'),
        termination_date: this.selectedEmployeeForDelete.termination_date,
        clearTerminationDate: false
    };
    this.editEmployeeDialog = true;
},
// Метод для создания стандартного календаря
createDefaultCalendar(year) {
    const calendar = [];
    for (let month = 1; month <= 12; month++) {
        for (let day = 1; day <= 31; day++) {
            const dateStr = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
            const date = moment(dateStr);
            if (date.isValid() && date.year() === year) {
                const dayOfWeek = date.day();
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                calendar.push({
                    date: dateStr,
                    type: isWeekend ? 'weekend' : 'working',
                    description: isWeekend ? 'Выходной' : 'Рабочий день'
                });
            }
        }
    }
    
    if (!this.productionCalendars) {
        this.productionCalendars = {};
    }
    this.productionCalendars[year] = calendar;
    this.productionCalendar = calendar;
},
 async callApi(method, filter, select, entityTypeId, batchNumber, parsed) {
    let total = 0;
    const maxTotal = 50;
    let data = [];
    const params = {
        filter: filter ? filter : null,
        select: select ? select : null,
        entityTypeId: entityTypeId ? entityTypeId : null,
        id: method === "crm.dealcategory.stage.list" ? entityTypeId : null,
        start: 0,
    };

    const exceptions = ["crm.status.list"];

    await new Promise((resolve) => {
        BX24.callMethod(method, params, (res) => {
            if (res.data()) {
                total = res.total();
                data = res.data();
                parsed += total;
                resolve(data);
            }
        });
    });

    if (total > maxTotal && !exceptions.includes(method)) {
        let cmd = {};
        const iterations = Math.min(Math.ceil((total - 0 * 2500) / maxTotal), 50);
        let resultData = [];
        for (let i = 0; i < iterations; i++) {
            const key = `cmd${i}`;
            const value = {
                method: method,
                params: {
                    filter: filter || null,
                    select: select || null,
                    entityTypeId: entityTypeId || null,
                    id: method === "crm.dealcategory.stage.list" ? entityTypeId : null,
                    start: (0 * 2500) + i * maxTotal,
                }
            };
            cmd[key] = value;
            if ((i + 1) % maxTotal === 0 || i + 1 === iterations) {
                const batchLength = (i + 1) % maxTotal === 0 ? maxTotal : iterations % maxTotal;
                await new Promise((resolve) => {
                    BX24.callBatch(cmd, (res) => {
                        for (let r = i - batchLength + 1; r < i + 1; r++) {
                            const key = `cmd${r}`;
                            const data = res[key].data();
                            const data2 = data.items ? data.items : data;
                            resultData.push(data2);
                        }
                        resultData = resultData.flat();
                        data = resultData;
                        cmd = {};
                        resolve();
                    });
                });
                break;
            }
        }
    }
    return data.items ? data.items : data;
},
                // API методы
                async apiCall(url, options = {}) {
                    try {
                        const response = await fetch(url, {
                            headers: {
                                'Content-Type': 'application/json',
                                ...options.headers
                            },
                            ...options
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        if (!data.success) {
                            throw new Error(data.error || 'Unknown error');
                        }
                        
                        return data;
                    } catch (error) {
                        console.error('API Error:', error);
                        throw error;
                    }
                },

                async loadEmployees() {
                    try {
                        const data = await this.apiCall(`${API_BASE}/employees.php`);
                        this.employees = data.data.map(emp => ({
                            ...emp,
                            schedule: {}
                        }));
                    } catch (error) {
                        this.showError('Ошибка загрузки сотрудников: ' + error.message);
                    }
                },
                confirmRemoveEmployee() {
                    if (!this.selectedEmployeeForDelete) return;
                    
                    if (confirm(`Вы уверены, что хотите удалить сотрудника "${this.selectedEmployeeForDelete.name}"?`)) {
                        this.removeEmployee();
                    }
                },
                async loadDeals() {
                    try {
                        this.deals = await this.callApi("crm.deal.list", 
                            {"!UF_CRM_1755511210978": "null", 
                            ">UF_CRM_1755511228885": moment().subtract(1, 'month').format('DD.MM.YYYY'), 
                            "!UF_CRM_1755511268203": "null"}, 
                            ["ID", "UF_CRM_1755511210978", "UF_CRM_1755511228885", "UF_CRM_1755511268203"]);
                        
                        // Инвалидируем кэш при загрузке новых сделок
                        this.invalidateCache();
                    } catch (error) {
                        this.showError('Ошибка загрузки сделок: ' + error.message);
                    }
                },

                async loadSchedule() {
                    if (!this.tableDateStart || !this.tableDateEnd) return;
                    
                    try {
                        const data = await this.apiCall(
                            `${API_BASE}/schedule.php?start_date=${this.tableDateStart}&end_date=${this.tableDateEnd}`
                        );
                        
                        // Очищаем расписания
                        this.employees.forEach(emp => {
                            emp.schedule = {};
                        });
                        
                        // Заполняем расписания из данных API
                        data.data.forEach(item => {
                            const employee = this.employees.find(e => e.name === item.name);
                            if (employee && item.date) {
                                employee.schedule[item.date] = item.status;
                            }
                        });
                    } catch (error) {
                        this.showError('Ошибка загрузки графика: ' + error.message);
                    }
                },

                async refreshData() {
                    this.loading = true;
                    try {
                        await Promise.all([
                            this.loadEmployees(),
                            this.loadDeals(),
                            this.loadSchedule()
                        ]);

                        if (this.currentView === 'planning') {
                            // Используем оптимизированную версию
                            await this.updateChart();
                        }
                    } catch (error) {
                        this.showError('Ошибка обновления данных: ' + error.message);
                    } finally {
                        this.loading = false;
                    }
                },


                async addEmployee() {
                    if (!this.newEmployee.name) {
                        this.showError('Введите имя сотрудника');
                        return;
                    }

                    this.addingEmployee = true;
                    try {
                        await this.apiCall(`${API_BASE}/employees.php`, {
                            method: 'POST',
                            body: JSON.stringify({ name: this.newEmployee.name })
                        });
                        
                        this.newEmployee.name = '';
                        await this.loadEmployees();
                        await this.loadScheduleData();
                        this.showSuccess('Сотрудник добавлен');
                    } catch (error) {
                        this.showError('Ошибка добавления сотрудника: ' + error.message);
                    } finally {
                        this.addingEmployee = false;
                    }
                },

                async removeEmployee() {
                    if (!this.selectedEmployeeForDelete) return;

                    this.deletingEmployee = true;
                    try {
                        const terminationDate = moment().format('YYYY-MM-DD');
                        await this.apiCall(`${API_BASE}/employees.php`, {
                            method: 'DELETE',
                            body: JSON.stringify({ 
                                id: this.selectedEmployeeForDelete.id,
                                termination_date: terminationDate 
                            })
                        });
                        
                        this.selectedEmployeeForDelete = null;
                        await this.loadEmployees();
                        this.showSuccess('Сотрудник удален');
                    } catch (error) {
                        this.showError('Ошибка удаления сотрудника: ' + error.message);
                    } finally {
                        this.deletingEmployee = false;
                    }
                },

                async saveIconChange() {
                    if (!this.currentEmployee || !this.currentDate || !this.selectedStatus) return;

                    this.savingStatus = true;
                    try {
                        await this.apiCall(`${API_BASE}/schedule.php`, {
                            method: 'POST',
                            body: JSON.stringify({
                                employee_id: this.currentEmployee.id,
                                date: this.currentDate,
                                status: this.selectedStatus
                            })
                        });
                        
                        // Обновляем локальные данные
                        this.currentEmployee.schedule[this.currentDate] = this.selectedStatus;
                        this.iconDialog = false;
                        this.showSuccess('Статус обновлен');
                    } catch (error) {
                        this.showError('Ошибка сохранения статуса: ' + error.message);
                    } finally {
                        this.savingStatus = false;
                    }
                },

                async applySchedule() {
                    if (!this.selectedEmployee) {
                        this.showError('Выберите сотрудника');
                        return;
                    }

                    this.loading = true;
                    try {
                        if (this.scheduleAction === 'production_calendar') {
                            // Применяем производственный календарь для выбранного сотрудника
                            await this.applyCalendarToEmployee(this.selectedEmployee);
                        } else {
                            // Стандартная логика применения графика
                            if (!this.scheduleDateStart || !this.scheduleDateEnd) {
                                this.showError('Заполните все поля');
                                return;
                            }

                            await this.apiCall(`${API_BASE}/schedule.php`, {
                                method: 'POST',
                                body: JSON.stringify({
                                    bulk_update: true,
                                    employee_id: this.selectedEmployee.id,
                                    start_date: this.scheduleDateStart,
                                    end_date: this.scheduleDateEnd,
                                    status: this.scheduleAction
                                })
                            });
                        }
                        
                        await this.loadSchedule();
                        this.showSuccess('График обновлен');
                        
                    } catch (error) {
                        this.showError('Ошибка применения графика: ' + error.message);
                    } finally {
                        this.loading = false;
                    }
                },

                async addDeal() {
                    if (!this.canAddDeal) return;

                    this.loading = true;
                    try {
                        await this.apiCall(`${API_BASE}/deals.php`, {
                            method: 'POST',
                            body: JSON.stringify({
                                man_days: this.newDeal.manDays,
                                start_date: this.newDeal.startDate,
                                end_date: this.newDeal.endDate
                            })
                        });
                        
                        await this.loadDeals();
                        this.updateChart();
                        this.newDeal = { 
                            manDays: 5, 
                            startDate: moment().format('YYYY-MM-DD'), 
                            endDate: moment().add(6, 'days').format('YYYY-MM-DD') 
                        };
                        this.dealCheckResult = null;
                        this.canAddDeal = false;
                        this.showSuccess('Сделка добавлена');
                    } catch (error) {
                        this.showError('Ошибка добавления сделки: ' + error.message);
                    } finally {
                        this.loading = false;
                    }
                },

                async deleteDeal(dealId) {
                    this.loading = true;
                    try {
                        await this.apiCall(`${API_BASE}/deals.php`, {
                            method: 'DELETE',
                            body: JSON.stringify({ id: dealId })
                        });
                        
                        await this.loadDeals();
                        this.updateChart();
                        this.showSuccess('Сделка удалена');
                    } catch (error) {
                        this.showError('Ошибка удаления сделки: ' + error.message);
                    } finally {
                        this.loading = false;
                    }
                },

                // Вспомогательные методы
                showError(message) {
                    this.errorMessage = message;
                    setTimeout(() => {
                        this.errorMessage = '';
                    }, 5000);
                },

                showSuccess(message) {
                    this.successMessage = message;
                    setTimeout(() => {
                        this.successMessage = '';
                    }, 3000);
                },

                formatDate(dateStr) {
                    return moment(dateStr).format('DD.MM.YYYY');
                },

                formatDateTime(dateTimeStr) {
                    return moment(dateTimeStr).format('DD.MM.YYYY HH:mm');
                },

                handleWheelScroll(e) {
                    if (Math.abs(e.deltaX) < Math.abs(e.deltaY)) {
                        this.$refs.tableWrapper.scrollLeft += e.deltaY;
                        e.preventDefault();
                    }
                },

                planning(){
                    this.currentView = 'planning';
                    setTimeout(() => {
                        this.updateChart();
                    }, 200);
                }, 

                loadTable(){
                    this.currentView = 'loadTable';
                    this.loadScheduleData();
                },

                async loadScheduleData() {
                    this.loading = true;
                    try {
                        await this.loadSchedule();
                    } catch (error) {
                        this.showError('Ошибка загрузки графика: ' + error.message);
                    } finally {
                        this.loading = false;
                    }
                },
                formatTableDate(date) {
                    const m = moment(date);
                    return m.format('DD.MM') + '\n' + m.format('ddd');
                },

                changeIcon(employee, date) {
                    // Не позволяем изменять статус для уволенных сотрудников или до даты приема
                    //if (this.isEmployeeTerminated(employee, date) || !this.isEmployeeHired(employee, date)) {
                    //    this.showError('Нельзя изменить статус для этого периода');
                    //    return;
                    //}
                    
                    this.currentEmployee = employee;
                    this.currentDate = date;
                    const currentStatus = employee.schedule[date];
                     if (!currentStatus) {
                        if(this.isEmployeeTerminated(employee, date)){
                            this.selectedStatus = 'terminated';
                        }else if(this.isEmployeeHired(employee, date)){
                            this.selectedStatus = 'not-hired';
                        }else{
                            this.selectedStatus = this.isWeekend(date) ? 'weekend' : 'working';
                        }
                    } else {
                        this.selectedStatus = currentStatus;
                    }

                    this.iconDialog = true;
                },
                getCellClass(employee, date) {
                    if (this.isEmployeeTerminated(employee, date)) {
                        return 'terminated';
                    }
                        
                        // Проверяем статус приема
                    if (!this.isEmployeeHired(employee, date)) {
                        return 'not-hired';
                    }
                        
                    const status = employee.schedule[date];
                    // Сначала проверяем специальные статусы
                    if (status === 'terminated') return 'terminated';
                    if (status === 'not_hired') return 'not-hired';
                    
                    // Затем обычные статусы
                    if (status === 'vacation') return 'vacation';
                    if (status === 'sick') return 'sick';
                    if (status === 'weekend') return 'weekend';
                    if (status === 'working') return 'working';
                    
                    // По умолчанию - проверяем выходной
                    return this.isWeekend(date) ? 'weekend' : 'working';
                },
getCellContent(employee, date) {
    const status = employee.schedule[date];
    if (this.isEmployeeTerminated(employee, date)) {
        return {
            icon: 'mdi-account-off',
            tooltip: 'Уволен',
            color: 'grey darken-2'
        };
    }

    if (!this.isEmployeeHired(employee, date)) {
        return {
            icon: 'mdi-account-clock',
            tooltip: 'Еще не принят',
            color: 'blue-grey lighten-2'
        };
    }

    if (status === 'terminated') {
        return {
            icon: 'mdi-account-off',
            tooltip: 'Уволен',
            color: 'grey darken-2'
        };
    }
    
    if (status === 'not_hired') {
        return {
            icon: 'mdi-account-clock',
            tooltip: 'Еще не принят',
            color: 'blue-grey lighten-2'
        };
    }
    
    if (status === 'vacation') {
        return {
            icon: 'mdi-palm-tree',
            tooltip: 'Отпуск',
            color: 'orange'
        };
    }
    if (status === 'sick') {
        return {
            icon: 'mdi-hospital-box',
            tooltip: 'Больничный',
            color: 'red'
        };
    }
    if (status === 'weekend') {
        return {
            icon: 'mdi-sofa',
            tooltip: 'Выходной',
            color: 'grey'
        };
    }
    if (status === 'working') {
        return {
            icon: 'mdi-briefcase',
            tooltip: 'Рабочий день',
            color: 'green'
        };
    }
    
    return this.isWeekend(date) 
        ? {
            icon: 'mdi-sofa',
            tooltip: 'Выходной',
            color: 'grey'
        } 
        : {
            icon: 'mdi-briefcase',
            tooltip: 'Рабочий день',
            color: 'green'
        };
},
                // МЕТОДЫ ДЛЯ ПРАВИЛЬНОГО РАСЧЕТА ЧЕЛОВЕКО-ДНЕЙ
                // Основной метод проверки возможности добавления сделки
                async checkDeal() {

                    if (!this.newDeal.manDays || !this.newDeal.startDate || !this.newDeal.endDate) {
                        this.showError('Заполните все поля сделки');
                        return;
                    }

                    this.checkingDeal = true;
                    await this.checkDealWithRedistribution();
                    /*
                    try {
                        const start = moment(this.newDeal.startDate);
                        const end = moment(this.newDeal.endDate);
                        
                        let totalAvailableMinusOccupied = 0;
                        let canAdd = true;
                        let problemDate = null;
                        
                        // Считаем рабочие дни в периоде сделки
                        const workDaysInDeal = this.countWorkDaysInPeriod(start, end);
                        
                        if (workDaysInDeal === 0) {
                            this.dealCheckResult = 'В выбранном периоде нет рабочих дней';
                            this.canAddDeal = false;
                            return;
                        }

                        // Проверяем каждую дату в периоде сделки
                        const currentDate = start.clone();
                        while (currentDate.isSameOrBefore(end)) {
                            const dateStr = currentDate.format('YYYY-MM-DD');
                            
                            // Получаем доступные человеко-дни на эту дату (уже с учетом расписания)
                            const availableManDays = this.getAvailableManDays(dateStr);
                            
                            // Получаем занятые человеко-дни на эту дату
                            const occupiedManDays = await this.getOccupiedManDays(dateStr);
                            
                            // Вычисляем свободные человеко-дни (доступные - занятые)
                            const freeManDays = availableManDays - occupiedManDays;
                            
                            // Накопляем общее количество свободных человеко-дней
                            totalAvailableMinusOccupied += freeManDays;
                            
                            // Если свободных человеко-дней меньше 0, сразу отказываем
                            if (freeManDays < 0) {
                                canAdd = false;
                                problemDate = dateStr;
                                break;
                            }
                            
                            currentDate.add(1, 'day');
                        }
                        
                        if (!canAdd) {
                            this.dealCheckResult = `Нельзя добавить сделку. Недостаточно ресурсов на дату ${this.formatDate(problemDate)}`;
                            this.canAddDeal = false;
                            return;
                        }
                        
                        // Вычисляем коэффициент загрузки: требуемые ЧД / свободные ЧД
                        const capacityRatio = totalAvailableMinusOccupied > 0 ? 
                            this.newDeal.manDays / totalAvailableMinusOccupied : 0;
                        
                        // Проверяем условие: коэффициент загрузки должен быть ≤ 0.9 (90%)
                        if (capacityRatio <= 0.9) {
                            this.dealCheckResult = `Можно добавить сделку. Коэффициент загрузки: ${(capacityRatio * 100).toFixed(1)}% (${this.newDeal.manDays} ЧД / ${totalAvailableMinusOccupied.toFixed(1)} свободных ЧД)`;
                            await new Promise((resolve) => {
                                    BX24.callMethod(
                                        "crm.deal.update",
                                        {
                                            id: 13039,
                                            fields: {
                                                UF_CRM_1751532386933: this.newDeal.startDate,
                                                UF_CRM_1751532395170: this.newDeal.endDate,
                                                UF_CRM_1751532404575: this.newDeal.manDays,
                                            },
                                        },
                                        function(result) {
                                        if (result.error()) {
                                            console.error('Ошибка добавления комментария:', result.error())
                                        }
                                        resolve()
                                        }
                                    )
                                    })
                            this.canAddDeal = true;
                        } else {
                            this.dealCheckResult = `Нельзя добавить сделку. Коэффициент загрузки ${(capacityRatio * 100).toFixed(1)}% превышает допустимые 90%. Требуется ${this.newDeal.manDays} ЧД, доступно ${totalAvailableMinusOccupied.toFixed(1)} свободных ЧД`;
                            this.canAddDeal = false;
                        }
                            await new Promise((resolve) => {
                                    BX24.callMethod(
                                        "crm.timeline.comment.add",
                                        {
                                        fields: {
                                            ENTITY_ID: "13039",
                                            ENTITY_TYPE: "deal",
                                            COMMENT: this.dealCheckResult,
                                        }
                                        },
                                        function(result) {
                                        if (result.error()) {
                                            console.error('Ошибка добавления комментария:', result.error())
                                        }
                                        resolve()
                                        }
                                    )
                                    })
                                   
                    } catch (error) {
                        this.showError('Ошибка проверки сделки: ' + error.message);
                        this.canAddDeal = false;
                    } finally {
                        this.checkingDeal = false;
                    } */
                },
                isEmployeeAvailable(employee, date) {
                    const status = employee.schedule[date];
                    
                    // Если статус явно указан как рабочий день - сотрудник доступен (даже в выходной)
                    if (status === 'working') return true;
                    
                    // Если статус указан как нерабочий - сотрудник недоступен
                    if (status === 'vacation' || status === 'sick' || status === 'weekend') return false;
                    
                    // Если статус не указан, используем календарь: в рабочие дни доступен, в выходные - нет
                    return !this.isWeekend(date);
                },
                // Метод для расчета занятых человеко-дней на конкретную дату
async getOccupiedManDays(date) {

    let totalLoad = 0;
    const currentMoment = moment(date);
    const availableManDays = this.getAvailableManDays(date);
    
    // Проходим по всем сделкам
    for (const deal of this.deals) {
        const dealStart = moment(deal.UF_CRM_1755511210978).subtract(1, 'day');
        const dealEnd = moment(deal.UF_CRM_1755511228885);
        // Если дата попадает в период сделки
        if (currentMoment.isBetween(dealStart, dealEnd, null, '[]')) {
            // Считаем РАБОЧИЕ дни в периоде сделки (исключая нерабочие)
            const workDaysInDeal = this.countWorkDaysInPeriod(dealStart, dealEnd) - 1;
            if (workDaysInDeal > 0) {
                // Рассчитываем дневную нагрузку для этой сделки
                const dailyLoad = deal.UF_CRM_1755511268203 / workDaysInDeal;
                // Проверяем, не превысит ли добавление этой нагрузки доступную емкость
                if (totalLoad + dailyLoad > availableManDays) {
                    // Если превышает, ограничиваем нагрузку доступной емкостью
                    totalLoad = availableManDays;
                    break; // Дальнейшие сделки не могут добавить нагрузку
                } else {
                    totalLoad += dailyLoad;
                }
            }
        }
    }
    
    // Гарантируем, что занятость не превышает доступную емкость
    return Math.min(totalLoad, availableManDays);
},
async addDealWithRedistribution() {
    if (!this.canAddDeal) return;

    this.loading = true;
    try {
        // Сначала добавляем сделку
        await this.apiCall(`${API_BASE}/deals.php`, {
            method: 'POST',
            body: JSON.stringify({
                man_days: this.newDeal.manDays,
                start_date: this.newDeal.startDate,
                end_date: this.newDeal.endDate
            })
        });
        
        // Затем автоматически оптимизируем распределение нагрузки
        await this.optimizeWorkloadDistribution();
        
        await this.loadDeals();
        this.updateChart();
        this.newDeal = { 
            manDays: 5, 
            startDate: moment().format('YYYY-MM-DD'), 
            endDate: moment().add(6, 'days').format('YYYY-MM-DD') 
        };
        this.dealCheckResult = null;
        this.canAddDeal = false;
        this.showSuccess('Сделка добавлена и нагрузка оптимизирована');
    } catch (error) {
        this.showError('Ошибка добавления сделки: ' + error.message);
    } finally {
        this.loading = false;
    }
},

// Метод для оптимизации распределения нагрузки между сделками
async optimizeWorkloadDistribution() {
    try {
        const startDate = moment().subtract(1, 'month'); // Начинаем с месяца назад
        const endDate = moment().add(3, 'months'); // Планируем на 3 месяца вперед
        
        const optimizationPeriod = [];
        let currentDate = startDate.clone();
        
        // Собираем данные по всем дням в периоде оптимизации
        while (currentDate.isSameOrBefore(endDate)) {
            const dateStr = currentDate.format('YYYY-MM-DD');
            
            if (!this.isWeekend(dateStr)) {
                const available = this.getAvailableManDays(dateStr);
                const occupied = await this.getOccupiedManDays(dateStr);
                
                optimizationPeriod.push({
                    date: dateStr,
                    available: available,
                    occupied: occupied,
                    free: Math.max(0, available - occupied),
                    overload: Math.max(0, occupied - available)
                });
            }
            
            currentDate.add(1, 'day');
        }
        
        // Находим перегруженные дни
        const overloadedDays = optimizationPeriod.filter(day => day.overload > 0);
        
        for (const overloadedDay of overloadedDays) {
            // Находим дни с достаточной емкостью для перераспределения
            const candidateDays = optimizationPeriod
                .filter(day => 
                    moment(day.date).isAfter(overloadedDay.date) && // Будущие дни
                    day.free > 0 &&
                    !this.isWeekend(day.date)
                )
                .sort((a, b) => a.free - b.free); // Сортируем по возрастанию свободной емкости
            
            let remainingOverload = overloadedDay.overload;
            
            for (const candidateDay of candidateDays) {
                if (remainingOverload <= 0) break;
                
                const loadToMove = Math.min(remainingOverload, candidateDay.free);
                if (loadToMove > 0) {
                    // Здесь должна быть логика фактического перемещения нагрузки между сделками
                    // Например, изменение дат выполнения задач или перераспределение ресурсов
                    remainingOverload -= loadToMove;
                    
                    // Обновляем данные о емкости
                    candidateDay.free -= loadToMove;
                    candidateDay.occupied += loadToMove;
                    overloadedDay.occupied -= loadToMove;
                    overloadedDay.free += loadToMove;
                }
            }
        }
        
    } catch (error) {
        console.error('Ошибка оптимизации нагрузки:', error);
    }
},
async checkDealWithRedistribution() {
    if (!this.newDeal.manDays || !this.newDeal.startDate || !this.newDeal.endDate) {
        this.showError('Заполните все поля сделки');
        return;
    }
    this.checkingDeal = true;
    
    try {
        // Предварительно вычисляем данные для периода сделки
        await this.preCalculateOccupancyForRange(this.newDeal.startDate, this.newDeal.endDate);
        
        const start = moment(this.newDeal.startDate);
        const end = moment(this.newDeal.endDate);
        
        const workDaysInDeal = this.countWorkDaysInPeriod(start, end);
        
        if (workDaysInDeal === 0) {
            this.dealCheckResult = 'В выбранном периоде нет рабочих дней';
            this.canAddDeal = false;
            return;
        }

        const requiredDailyLoad = this.newDeal.manDays / workDaysInDeal;
        
        let totalAvailableCapacity = 0;
        let dailyCapacityData = [];
        let problemDates = [];
        
        const currentDate = start.clone();
        while (currentDate.isSameOrBefore(end)) {
            const dateStr = currentDate.format('YYYY-MM-DD');
            
            if (this.isWeekend(dateStr)) {
                currentDate.add(1, 'day');
                continue;
            }
            
            // Используем кэшированные данные
            const available = this.getAvailableManDays(dateStr);
            const occupied = this.occupancyCache[dateStr] || 0;
            const free = Math.max(0, available - occupied);
            
            dailyCapacityData.push({
                date: dateStr,
                available: available,
                occupied: occupied,
                free: free,
                required: requiredDailyLoad
            });
            
            if (free < requiredDailyLoad) {
                problemDates.push({
                    date: dateStr,
                    deficit: requiredDailyLoad - free,
                    free: free,
                    available: available,
                    occupied: occupied
                });
            }
            
            totalAvailableCapacity += free;
            currentDate.add(1, 'day');
        }

        // Если нет проблем и коэффициент ок
        const capacityRatio = totalAvailableCapacity > 0 ? 
            this.newDeal.manDays / totalAvailableCapacity : 0;
        
        if (problemDates.length === 0) {
            if (capacityRatio <= 0.9) {
                this.dealCheckResult = `Можно добавить сделку на даты ${this.newDeal.startDate} / ${this.newDeal.endDate}. Коэффициент загрузки: ${(capacityRatio * 100).toFixed(1)}% (${this.newDeal.manDays} ЧД / ${totalAvailableCapacity.toFixed(1)} свободных ЧД)`;
                await new Promise((resolve) => {
                    BX24.callMethod(
                        "crm.deal.update",
                        {
                            id: BX24.placement.info().options.ID,
                            fields: {
                                UF_CRM_1751532386933: this.newDeal.startDate,
                                UF_CRM_1751532395170: this.newDeal.endDate,
                                UF_CRM_1751532404575: this.newDeal.manDays,
                            },
                        },
                        function(result) {
                            if (result.error()) {
                                console.error('Ошибка обновления сделки:', result.error())
                            }
                            resolve()
                        }
                    )
                });
                this.canAddDeal = true;
            } else {
                this.dealCheckResult = `Нельзя добавить сделку на даты ${this.newDeal.startDate} / ${this.newDeal.endDate}. Коэффициент загрузки ${(capacityRatio * 100).toFixed(1)}% превышает допустимые 90%. Требуется ${this.newDeal.manDays} ЧД, доступно ${totalAvailableCapacity.toFixed(1)} свободных ЧД`;
                this.canAddDeal = false;
            }
        } else {
            // Пытаемся перераспределить внутри периода
            const sortedDays = dailyCapacityData
                .filter(day => !this.isWeekend(day.date))
                .sort((a, b) => b.free - a.free);
            
            let totalRedistributableLoad = problemDates.reduce((sum, problem) => sum + problem.deficit, 0);
            let remainingLoad = totalRedistributableLoad;
            
            for (const day of sortedDays) {
                if (remainingLoad <= 0) break;
                
                if (problemDates.some(problem => problem.date === day.date)) continue;
                
                const additionalCapacity = Math.max(0, day.free - day.required);
                
                if (additionalCapacity > 0) {
                    const loadToMove = Math.min(remainingLoad, additionalCapacity);
                    remainingLoad -= loadToMove;
                    
                    day.free -= loadToMove;
                    day.occupied += loadToMove;
                }
            }

            if (remainingLoad <= 0) {
                this.dealCheckResult = `Можно добавить сделку на даты ${this.newDeal.startDate} / ${this.newDeal.endDate}. Коэффициент загрузки: ${(capacityRatio * 100).toFixed(1)}% (${this.newDeal.manDays} ЧД / ${totalAvailableCapacity.toFixed(1)} свободных ЧД)`;
                await new Promise((resolve) => {
                    BX24.callMethod(
                        "crm.deal.update",
                        {
                            id: BX24.placement.info().options.ID,
                            fields: {
                                UF_CRM_1751532386933: this.newDeal.startDate,
                                UF_CRM_1751532395170: this.newDeal.endDate,
                                UF_CRM_1751532404575: this.newDeal.manDays,
                            },
                        },
                        function(result) {
                            if (result.error()) {
                                console.error('Ошибка обновления сделки:', result.error())
                            }
                            resolve()
                        }
                    )
                });
                this.canAddDeal = true;
            } else {
                // Расширение периода за счет следующих дней
                let extendedEnd = end.clone();
                let extendedWorkDays = workDaysInDeal;
                const maxExtensions = 90; // Максимальное расширение в днях
                let extensions = 0;
                let fitted = false;

                while (true) {
                    extendedEnd.add(1, 'day');
                    const extendedDateStr = extendedEnd.format('YYYY-MM-DD');
                    if (!this.isWeekend(extendedDateStr)) {
                        extendedWorkDays += 1;
                    }
                    extensions += 1;

                    if (extensions > maxExtensions) {
                        this.dealCheckResult = `Нельзя добавить сделку. Не удалось найти подходящее расширение в пределах ${maxExtensions} дней.`;
                        this.canAddDeal = false;
                        break;
                    }

                    const newDailyLoad = this.newDeal.manDays / extendedWorkDays;

                    let fits = true;
                    let current = start.clone();
                    while (current.isSameOrBefore(extendedEnd)) {
                        const dStr = current.format('YYYY-MM-DD');
                        if (!this.isWeekend(dStr)) {
                            const free = await this.getFreeManDays(dStr);
                            if (free < newDailyLoad) {
                                fits = false;
                                break;
                            }
                        }
                        current.add(1, 'day');
                    }

                    if (fits) {
                        this.newDeal.endDate = extendedDateStr;
                        const newCapacityRatio = (this.newDeal.manDays / (totalAvailableCapacity + (extendedWorkDays - workDaysInDeal) * 5)) || 0; // Примерный расчет, скорректируйте по необходимости
                        this.dealCheckResult = `Сделка будет добавлена с расширением периода до ${this.newDeal.endDate} из-за нехватки ресурсов. Новый коэффициент загрузки: ${(newCapacityRatio * 100).toFixed(1)}%`;
                        await new Promise((resolve) => {
                            BX24.callMethod(
                                "crm.deal.update",
                                {
                                    id: BX24.placement.info().options.ID,
                                    fields: {
                                        UF_CRM_1751532386933: this.newDeal.startDate,
                                        UF_CRM_1751532395170: this.newDeal.endDate,
                                        UF_CRM_1751532404575: this.newDeal.manDays,
                                    },
                                },
                                function(result) {
                                    if (result.error()) {
                                        console.error('Ошибка обновления сделки:', result.error())
                                    }
                                    resolve()
                                }
                            )
                        });
                        this.canAddDeal = true;
                        fitted = true;
                        break;
                    }
                }

                if (!fitted) {
                    this.canAddDeal = false;
                }
            }
        }
        
        await new Promise((resolve) => {
            BX24.callMethod(
                "crm.timeline.comment.add",
                {
                    fields: {
                        ENTITY_ID: BX24.placement.info().options.ID,
                        ENTITY_TYPE: "deal",
                        COMMENT: this.dealCheckResult,
                    }
                },
                function(result) {
                    if (result.error()) {
                        console.error('Ошибка добавления комментария:', result.error())
                    }
                    resolve()
                }
            )
        });
                                   
    } catch (error) {
        this.showError('Ошибка проверки сделки: ' + error.message);
        this.canAddDeal = false;
    } finally {
        this.checkingDeal = false;
    }
},
async getFreeManDays(date) {
    const available = this.getAvailableManDays(date);
    const occupied = await this.getOccupiedManDays(date);
    
    // Свободные человеко-дни не могут быть меньше 0
    return Math.max(0, available - occupied);
},

// Метод для получения перегрузки (если занятость превышает доступность)
async getOverload(date) {
    const available = this.getAvailableManDays(date);
    const occupied = await this.getOccupiedManDays(date);
    
    // Перегруженность (положительное значение означает превышение лимита)
    return Math.max(0, occupied - available);
},
                // Метод для подсчета рабочих дней в периоде (исключая выходные)
                countWorkDaysInPeriod(start, end) {
                    let workDays = 0;
                    const current = start.clone();
                    
                    while (current.isSameOrBefore(end)) {
                        const dateStr = current.format('YYYY-MM-DD');
                        
                        // День считается рабочим, если он не выходной по календарю
                        // (статусы сотрудников не влияют на определение "рабочего дня" для расчета периода)
                        if (!this.isWeekend(dateStr)) {
                            workDays++;
                        }
                        current.add(1, 'day');
                    }
                    
                    return workDays;
                },

                // Метод для получения доступных человеко-дней на дату
                getAvailableManDays(date) {
                    const dateMoment = moment(date);
                    // Считаем количество сотрудников, доступных для работы в эту дату
                    const availableCount = this.employees.filter(emp => {
                        if (emp.created_at && moment(emp.created_at).isAfter(dateMoment, 'day')) {
                            return false; // Сотрудник еще не был принят
                        }

                        if (emp.termination_date && moment(emp.termination_date).isBefore(dateMoment, 'day')) {
                            return false;
                        }

                        const status = emp.schedule[date];
                        
                        // Если статус явно указан как рабочий день - сотрудник доступен (даже в выходной)
                        if (status === 'working') return true;
                        
                        // Если статус указан как нерабочий (отпуск, больничный, выходной) - сотрудник недоступен
                        if (status === 'vacation' || status === 'sick' || status === 'weekend' || status === 'terminated' || status === 'not_hired') return false;
                        
                        // Если статус не указан, проверяем является ли день выходным по календарю
                        // В выходные по умолчанию сотрудник недоступен
                        return !this.isWeekend(date);
                    }).length;
                    
                    // Гарантируем, что доступное количество не будет отрицательным
                    return Math.max(0, availableCount);
                },

                // Метод для проверки является ли день выходным
                isWeekend(date) {
                    const dateMoment = moment(date);
                    const year = dateMoment.year();
                    const dateStr = dateMoment.format('YYYY-MM-DD');
                    
                    // Проверяем стандартные выходные (суббота и воскресенье)
                    const dayOfWeek = dateMoment.day();
                    const isStandardWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                    
                    // Проверяем производственный календарь для соответствующего года
                    if (this.productionCalendars && this.productionCalendars[year]) {
                        const calendarDay = this.productionCalendars[year].find(d => d.date === dateStr);
                        if (calendarDay) {
                            return calendarDay.type === 'weekend';
                        }
                    }
                    
                    return isStandardWeekend;
                },
                async updateOccupancyData() {
                    this.occupancyData = [];
                    const startDate = moment();
                    const endDate = moment().add(30, 'days');
                    
                    for (let m = moment(startDate); m.isSameOrBefore(endDate); m.add(1, 'days')) {
                        const dateStr = m.format('YYYY-MM-DD');
                        const available = this.getAvailableManDays(dateStr);
                        const occupied = await this.getOccupiedManDays(dateStr);
                        
                        // Гарантируем, что свободные дни не могут быть отрицательными
                        const free = Math.max(0, available - occupied);
                        const percentage = available > 0 ? (occupied / available) * 100 : 0;
                        
                        this.occupancyData.push({
                            date: dateStr,
                            available: available,
                            occupied: occupied,
                            free: free,
                            percentage: percentage,
                            overload: Math.max(0, occupied - available) // Дополнительно храним данные о перегрузке
                        });
                    }
                },

                getOccupancyClass(percentage) {
                    if (percentage >= 90) return 'high-occupancy';
                    if (percentage >= 70) return 'medium-occupancy';
                    return 'low-occupancy';
                },

                getOccupancyStatus(percentage) {
                    if (percentage >= 90) return 'Высокая загрузка';
                    if (percentage >= 70) return 'Средняя загрузка';
                    return 'Низкая загрузка';
                },
                handleChartWheel(e) {
                    const chartContainer = document.getElementById('chartContainer');
                    if (!chartContainer) return;
                    
                    // Получаем текущую позицию скролла и размеры
                    const currentScrollLeft = chartContainer.scrollLeft;
                    const scrollWidth = chartContainer.scrollWidth;
                    const clientWidth = chartContainer.clientWidth;
                    
                    // Рассчитываем максимально возможную позицию скролла
                    const maxScrollLeft = scrollWidth - clientWidth;

                    // Определяем направление скролла
                    const scrollDelta = e.deltaY;
                    
                    // Проверяем границы
                    if ((scrollDelta > 0 && currentScrollLeft <= 0) || // Достигли начала
                        (scrollDelta < 0 && currentScrollLeft >= maxScrollLeft)) { // Достигли конца
                        e.preventDefault();
                        return;
                    }
                    
                    // Если не достигли границ, выполняем скролл
                    chartContainer.scrollLeft += scrollDelta;
                    e.preventDefault();
                },
                // Обновление графика загрузки
async updateChart() {
    const currentYear = moment().year();
        const nextYear = currentYear + 1;
        
        const startDate = moment("2025-08-01");
        const endDate = moment().endOf('year').add(1, 'year');
        
        // Предварительно вычисляем данные для всего периода
        await this.preCalculateOccupancyForRange(startDate.format('YYYY-MM-DD'), endDate.format('YYYY-MM-DD'));

        const categories = [];
        const availableData = [];
        const occupiedData = [];
        const freeData = [];

        const allDates = [];
        for (let m = moment(startDate); m.isSameOrBefore(endDate); m.add(1, 'days')) {
            allDates.push(m.format('YYYY-MM-DD'));
        }

        // Теперь данные берутся из кэша - очень быстро
        for (const dateStr of allDates) {
            const m = moment(dateStr);
            categories.push(m.format('DD.MM.YY'));
            
            const available = this.getAvailableManDays(dateStr);
            const occupied = this.occupancyCache[dateStr] || 0;
            const free = Math.max(0, available - occupied);
            
            availableData.push(available);
            occupiedData.push(occupied);
            freeData.push(free);
        }

        // Остальная часть метода updateChart без изменений
        Highcharts.chart('loadChart', {
        lang: {
            contextButtonTitle: "Контекстное меню",
            decimalPoint: ",",
            downloadJPEG: "Скачать JPEG",
            downloadPDF: "Скачать PDF",
            downloadPNG: "Скачать PNG",
            downloadSVG: "Скачать SVG",
            downloadCSV: "Скачать CSV",
            downloadXLS: "Скачать XLS",
            viewFullscreen: "Полноэкранный режим",
            viewData: "",
            drillUpText: "Назад к {series.name}",
            loading: "Загрузка...",
            months: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", 
                    "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"],
            noData: "Нет данных для отображения",
            printChart: "Напечатать график",
            resetZoom: "Сбросить масштаб",
            resetZoomTitle: "Сбросить масштаб 1:1",
            shortMonths: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", 
                        "Июл", "Август", "Сен", "Окт", "Ноя", "Дек"],
            thousandsSep: " ",
            weekdays: ["Воскресенье", "Понедельник", "Вторник", "Среда", 
                    "Четверг", "Пятница", "Суббота"]
        },
                chart: {
            type: 'line',
            zoomType: 'x',
            panning: true,
            panKey: 'shift',
            events: {
                load: function() {
                    const chart = this;
                    const initialDays = 30; // Показываем 60 дней изначально
                    
                    // Находим индекс сегодняшней даты
                    const today = moment().format('DD.MM.YY');
                    const todayIndex = categories.indexOf(today);
                    
                    // Устанавливаем начальный видимый диапазон (30 дней до сегодня и 30 после)
                    const startIndex = Math.max(0, todayIndex);
                    const endIndex = Math.min(categories.length - 1, todayIndex + 30);
                    
                    chart.xAxis[0].setExtremes(startIndex, endIndex);
                    
                    // Добавляем кастомный скролл
                    chart.container.onwheel = function(e) {
                        e.preventDefault();
                        
                        const delta = e.deltaY || e.deltaX;
                        const scrollSpeed = 3; // Скорость скролла
                        
                        const xAxis = chart.xAxis[0];
                        const extremes = xAxis.getExtremes();
                        const range = extremes.max - extremes.min;
                        
                        // Рассчитываем новый диапазон
                        let newMin = extremes.min + (delta > 0 ? scrollSpeed : -scrollSpeed);
                        let newMax = extremes.max + (delta > 0 ? scrollSpeed : -scrollSpeed);
                        
                        // Проверяем границы
                        if (newMin < 0) {
                            newMin = 0;
                            newMax = range;
                        }
                        if (newMax >= categories.length) {
                            newMax = categories.length - 1;
                            newMin = newMax - range;
                        }
                        
                        // Применяем новый диапазон
                        xAxis.setExtremes(newMin, newMax, true, false);
                    };
                }
            }
        },
        title: {
            text: 'График загрузки ресурсов на ' + currentYear + (endDate.year() > currentYear ? '-' + nextYear : '')
        },
        subtitle: {
            text: 'Доступные и занятые человеко-дни по дням'
        },
        xAxis: {
            categories: categories,
            crosshair: true,
            labels: {
                rotation: -45,
                formatter: function() {
                    // Группируем подписи по месяцам для лучшей читаемости
                    const date = moment(this.value, 'DD.MM.YY');
                    const day = date.date();
                    const month = date.month();
                    // Для остальных дней показываем только число
                    return date.format('DD.MM.YY');
                }
            },
            //minRange: 7 // Минимальный диапазон - неделя
        },
        yAxis: {
            min: 0,
            title: {
                text: 'Человеко-дни'
            },
        },
        tooltip: {
            shared: true,
            formatter: function() {
                const pointIndex = this.points[0].point.index;
                const date = moment(this.points[0].series.xAxis.categories[pointIndex], 'DD.MM.YY');
                let s = '<b>' + date.format('DD.MM.YYYY (dddd)') + '</b>';
                this.points.forEach(point => {
                    s += '<br/><span style="color:' + point.color + '">\u25CF</span> ' + 
                        point.series.name + ': ' + point.y.toFixed(1);
                });
                return s;
            }
        },
        plotOptions: {
            line: {
                marker: {
                    enabled: false, // Отключаем маркеры для большого количества точек
                    radius: 2
                },
                lineWidth: 1
            },
            series: {
                cursor: 'pointer',
                point: {
                    events: {
                        click: function() {
                            // Обработчик клика по точке
                        }
                    }
                }
            }
        },
        series: [{
            name: 'Занятые ЧД',
            data: occupiedData,
            color: '#ff6384',
            lineWidth: 2
        }, {
            name: 'Свободные ЧД',
            data: freeData,
            color: '#4bc0c0',
            lineWidth: 2
        }],
        legend: {
            layout: 'horizontal',
            align: 'center',
            verticalAlign: 'bottom'
        },
        responsive: {
            rules: [{
                condition: {
                    maxWidth: 500
                },
                chartOptions: {
                    legend: {
                        layout: 'horizontal',
                        align: 'center',
                        verticalAlign: 'bottom'
                    },
                    xAxis: {
                        labels: {
                            rotation: -45
                        }
                    }
                }
            }]
        }
    });
},
                // Остальные методы остаются без изменений
                async apiCall(url, options = {}) {
                    try {
                        const response = await fetch(url, {
                            headers: {
                                'Content-Type': 'application/json',
                                ...options.headers
                            },
                            ...options
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        if (!data.success) {
                            throw new Error(data.error || 'Unknown error');
                        }
                        
                        return data;
                    } catch (error) {
                        console.error('API Error:', error);
                        throw error;
                    }
                },
async fixOverload() {
    const summary = await this.getLoadSummary(moment(), moment().add(60, 'days'));
    
    if (summary.totalOverload > 0) {
        this.showSuccess(`Автоматически исправляем перегрузку: ${summary.totalOverload.toFixed(1)} ЧД`);
        await this.optimizeWorkloadDistribution();
    }
},
async checkSystemOverload() {
    const thirtyDaysAgo = moment().subtract(30, 'days');
    const thirtyDaysAhead = moment().add(30, 'days');
    
    const summary = await this.getLoadSummary(thirtyDaysAgo, thirtyDaysAhead);
    
    if (summary.totalOverload > 0) {
        this.showError(`Обнаружена перегрузка: ${summary.totalOverload.toFixed(1)} ЧД в ${summary.overloadDays} днях`);
        return true;
    }
    
    return false;
},
async getLoadSummary(startDate, endDate) {
    const summary = {
        totalAvailable: 0,
        totalOccupied: 0,
        totalFree: 0,
        overloadDays: 0,
        totalOverload: 0,
        days: []
    };
    
    const currentDate = moment(startDate);
    const end = moment(endDate);
    
    while (currentDate.isSameOrBefore(end)) {
        const dateStr = currentDate.format('YYYY-MM-DD');
        
        if (!this.isWeekend(dateStr)) {
            const available = this.getAvailableManDays(dateStr);
            const occupied = await this.getOccupiedManDays(dateStr);
            const free = Math.max(0, available - occupied);
            const overload = Math.max(0, occupied - available);
            
            summary.days.push({
                date: dateStr,
                available,
                occupied,
                free,
                overload,
                isOverloaded: overload > 0
            });
            
            summary.totalAvailable += available;
            summary.totalOccupied += occupied;
            summary.totalFree += free;
            
            if (overload > 0) {
                summary.overloadDays++;
                summary.totalOverload += overload;
            }
        }
        
        currentDate.add(1, 'day');
    }
    
    return summary;
},
async normalizeWorkload() {
    try {
        const startDate = moment().subtract(1, 'month');
        const endDate = moment().add(3, 'months');
        
        const daysToNormalize = [];
        let currentDate = startDate.clone();
        
        // Собираем данные по всем дням
        while (currentDate.isSameOrBefore(endDate)) {
            const dateStr = currentDate.format('YYYY-MM-DD');
            
            if (!this.isWeekend(dateStr)) {
                const available = this.getAvailableManDays(dateStr);
                const occupied = await this.getOccupiedManDays(dateStr);
                const free = available - occupied;
                
                if (free < 0) {
                    daysToNormalize.push({
                        date: dateStr,
                        available: available,
                        occupied: occupied,
                        overload: -free, // Перегрузка (положительное число)
                        free: 0 // Принудительно устанавливаем free = 0
                    });
                }
            }
            
            currentDate.add(1, 'day');
        }
        
        // Обрабатываем дни с перегрузкой
        for (const overloadedDay of daysToNormalize) {
            // Находим ближайшие будущие дни с достаточной емкостью
            const futureDays = [];
            let futureDate = moment(overloadedDay.date).add(1, 'day');
            
            while (futureDate.isSameOrBefore(endDate) && overloadedDay.overload > 0) {
                const futureDateStr = futureDate.format('YYYY-MM-DD');
                
                if (!this.isWeekend(futureDateStr)) {
                    const futureAvailable = this.getAvailableManDays(futureDateStr);
                    const futureOccupied = await this.getOccupiedManDays(futureDateStr);
                    const futureFree = Math.max(0, futureAvailable - futureOccupied);
                    
                    if (futureFree > 0) {
                        futureDays.push({
                            date: futureDateStr,
                            free: futureFree,
                            available: futureAvailable,
                            occupied: futureOccupied
                        });
                    }
                }
                
                futureDate.add(1, 'day');
            }
            
            // Сортируем будущие дни по свободной емкости (по убыванию)
            futureDays.sort((a, b) => b.free - a.free);
            
            let remainingOverload = overloadedDay.overload;
            
            // Перераспределяем нагрузку на будущие дни
            for (const futureDay of futureDays) {
                if (remainingOverload <= 0) break;
                
                const loadToMove = Math.min(remainingOverload, futureDay.free);
                if (loadToMove > 0) {
                    // Здесь должна быть реальная логика перемещения задач между датами
                    console.log(`Перемещаем ${loadToMove.toFixed(1)} ЧД с ${overloadedDay.date} на ${futureDay.date}`);
                    
                    remainingOverload -= loadToMove;
                    futureDay.free -= loadToMove;
                }
            }
            
            // Если осталась нераспределенная нагрузка, логируем предупреждение
            if (remainingOverload > 0) {
                console.warn(`Не удалось распределить ${remainingOverload.toFixed(1)} ЧД перегрузки с ${overloadedDay.date}`);
            }
        }
        
    } catch (error) {
        console.error('Ошибка нормализации нагрузки:', error);
    }
},
                // Методы для работы с производственным календарем
                async loadProductionCalendar() {
                    this.loadingCalendar = true;
                    try {
                        const response = await fetch(`https://isdayoff.ru/api/getdata?year=${this.currentYear}&delimeter=,`);
                        const csvData = await response.text();
                        
                        this.productionCalendar = [];
                        const lines = csvData.split(',');
                        
                        for (let month = 1; month <= 12; month++) {
                            for (let day = 1; day <= 31; day++) {
                                const dateStr = `${this.currentYear}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                                const date = moment(dateStr);
                                if (date.isValid() && date.year() === this.currentYear) {
                                    const dayIndex = date.dayOfYear() - 1;
                                    if (dayIndex < lines.length) {
                                        const dayType = lines[dayIndex].trim();
                                        this.productionCalendar.push({
                                            date: dateStr,
                                            type: dayType === '1' ? 'weekend' : 'working',
                                            description: dayType === '1' ? 'Выходной/праздничный' : 'Рабочий день'
                                        });
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        this.showError('Ошибка загрузки производственного календаря: ' + error.message);
                    } finally {
                        this.loadingCalendar = false;
                    }
                },

                async refreshProductionCalendar() {
                    await this.loadProductionCalendar();
                },

                async applyCalendarToAll() {
                    this.applyingCalendar = true;
                    try {
                        for (const employee of this.employees) {
                            await this.applyCalendarToEmployee(employee);
                        }
                        await this.loadSchedule();
                        this.showSuccess('Производственный календарь применен ко всем сотрудникам');
                    } catch (error) {
                        this.showError('Ошибка применения календаря: ' + error.message);
                    } finally {
                        this.applyingCalendar = false;
                    }
                },

                async applyCalendarToEmployee(employee) {
                    try {
                        await this.apiCall(`${API_BASE}schedule.php`, {
                            method: 'DELETE',
                            body: JSON.stringify({
                                employee_id: employee.id,
                            })
                        });
                    } catch (error) {
                        throw error;
                    }
                },
                async loadOptimizedChartData() {
                    this.loading = true;
                    try {
                        const currentYear = moment().year();
                        const nextYear = currentYear + 1;
                        
                        // Предварительная загрузка всех необходимых данных
                        await Promise.all([
                            this.loadProductionCalendarForYear(currentYear),
                            this.loadProductionCalendarForYear(nextYear),
                            this.loadEmployees(),
                            this.loadDeals(),
                            this.loadSchedule()
                        ]);
                        
                        // Обновляем график
                        await this.updateChart();
                        
                    } catch (error) {
                        this.showError('Ошибка загрузки данных графика: ' + error.message);
                    } finally {
                        this.loading = false;
                    }
                },
            },
            watch: {
                tableDateStart() {
                    this.updateTableDates();
                },
                tableDateEnd() {
                    this.updateTableDates();
                }
            },
                async mounted() {
                    try {
                        await new Promise(resolve => setTimeout(resolve, 200));

                        // 1. Получаем информацию о пользователе
                        const userId = await new Promise((resolve) => {
                            BX24.callMethod("user.current", {}, (res) => {
                                resolve(res.data().ID);
                            });
                        });
                        this.isAdmin = userId == 21 || BX24.isAdmin();
                        
                        // 2. Показываем индикатор загрузки
                        this.loading = true;
                        
                        // 3. Загружаем производственный календарь для текущего года
                        await this.loadProductionCalendarForYear(this.currentYear);
                        
                        // 4. Загружаем основные данные последовательно
                        await this.loadEmployees();
                        await this.loadDeals();
                        await this.loadSchedule();
                        
                        // 5. Инициализируем кэш после загрузки данных
                        this.initCache();
                        
                        // 6. Обновляем таблицу дат
                        this.updateTableDates();
                        
                        // 7. Загружаем оптимизированные данные для графика
                        await this.loadOptimizedChartData();
                        
                        console.log('Все данные успешно загружены');
                        
                    } catch (error) {
                        console.error('Ошибка при загрузке данных:', error);
                        this.showError('Ошибка загрузки данных: ' + error.message);
                    } finally {
                        // 8. Скрываем индикатор загрузки независимо от результата
                        this.loading = false;
                    }
                },
        });
    </script>
</body>
</html>
